Bindings to =zmq= in Emacs.

* Installation
** Dependencies

- libzmq :: https://github.com/zeromq/libzmq
** Building

Run =make= in the top level directory to build the =zmq= module. This requires
that =automake= be available on your system.
** Testing

To run the available tests, run =make test= in the top level directory.
* Contexts

To create a context:

#+BEGIN_SRC elisp
(zmq-context)
#+END_SRC

Normally a single context object for the current Emacs session is necessary. So
to get a context, you should call =zmq-current-context= which will create a
context only if needed. See [[id:7E843F84-F15C-42EA-8BA5-BCB91717ABBE][Context/socket/poller lifetime management]].

Below is a table mapping the C API functions to their Emacs equivalent.

| C                  | emacs-lisp              |
|--------------------+-------------------------|
| =zmq_ctx_new=      | =zmq-context=           |
| =zmq_ctx_set=      | =zmq-context-set=       |
| =zmq_ctx_get=      | =zmq-context-get=       |
| =zmq_ctx_term=     | =zmq-context-terminate= |
| =zmq_ctx_shutdown= | =zmq-context-shutdown=  |
* Sockets
:PROPERTIES:
:Effort:   10
:END:

To create a socket:

#+BEGIN_SRC elisp
(zmq-socket (zmq-current-context) zmq-PUB)
#+END_SRC

To bind a socket:

#+BEGIN_SRC elisp
(zmq-bind sock "tcp://127.0.0.1:5555")
#+END_SRC

To receive a message without blocking:

#+BEGIN_SRC elisp
(let (msg)
  (while (null (condition-case err
                   (setq msg (zmq-recv sock zmq-NOBLOCK))
                (zmq-EAGAIN nil)))
    (sleep-for 1)))
#+END_SRC

Below is a table mapping the C API functions to their Emacs equivalent.

| C                    | emacs-lisp           |
|----------------------+----------------------|
| =zmq_socket=         | =zmq-socket=         |
| =zmq_send=           | =zmq-send=           |
| =zmq_recv=           | =zmq-recv=           |
| =zmq_bind=           | =zmq-bind=           |
| =zmq_unbind=         | =zmq-unbind=         |
| =zmq_connect=        | =zmq-connect=        |
| =zmq_disconnect=     | =zmq-disconnect=     |
| =zmq_close=          | =zmq-close=          |
| =zmq_setsockopt=     | =zmq-socket-set=     |
| =zmq_getsockopt=     | =zmq-socket-get=     |

In addition to the above, there are also some convenience functions for working
with sockets. Currently this is only the function =zmq-bind-to-random-port=
which takes a socket and an address and binds the socket to a random port on
the address:

#+BEGIN_SRC elisp
(zmq-bind-to-random-port sock "tcp://127.0.0.1") ; returns port number
#+END_SRC
* Messages

To create a new message object use =zmq-message=

#+BEGIN_SRC elisp
(zmq-message)
#+END_SRC

The above creates and initializes an empty message. You can also pass a string
or a vector of bytes to =zmq-message= to initialize the message with some data

#+BEGIN_SRC elisp
(zmq-message "[mα, mβ] = iℏmγ")
;; Initialize a message with a vector of bytes
(zmq-message [0 10 100 29])
#+END_SRC

Below is a table mapping the C API functions to their Emacs equivalent.

| C                        | emacs-lisp                   |
|--------------------------+------------------------------|
| =zmq_msg_init=           | =zmq-message=                |
| =zmq_msg_init_data=      | =zmq-message=                |
| =zmq_msg_recv=           | =zmq-message-recv=           |
| =zmq_msg_send=           | =zmq-message-send=           |
| =zmq_msg_move=           | =zmq-message-move=           |
| =zmq_msg_copy=           | =zmq-message-copy=           |
| =zmq_msg_close=          | =zmq-message-close=          |
| =zmq_msg_data=           | =zmq-message-data=           |
| =zmq_msg_size=           | =zmq-message-size=           |
| =zmq_msg_more=           | =zmq-message-more-p=         |
| =zmq_msg_set=            | =zmq-message-set=            |
| =zmq_msg_get=            | =zmq-message-get=            |
| =zmq_msg_gets=           | =zmq-message-property=       |
| =zmq_msg_routing_id=     | =zmq-message-routing-id=     |
| =zmq_msg_set_routing_id= | =zmq-message-set-routing-id= |
** Multi-part messages

To send a multi-part message:

#+BEGIN_SRC elisp
(zmq-send-multipart sock '("part1" "part2" "part3"))
#+END_SRC

To receive a multi-part message:

#+BEGIN_SRC elisp
(zmq-recv-multipart sock)
#+END_SRC

=zmq-recv-multipart= returns a list containing the parts of the message and
always returns a list, even for a message containing a single part.
* Polling

Currently, polling requires that =libzmq= be built with the draft API to expose
the =zmq_poller= interface.

#+BEGIN_SRC elisp
(catch 'recvd
  (let ((poller (zmq-poller))
        (timeout 1000))
    (zmq-poller-add poller sock (list zmq-POLLIN zmq-POLLOUT))
    (while t
      ;; `zmq-poller-wait-all' returns an alist of elements (sock . events)
      (let* ((socks-events (zmq-poller-wait-all items timeout))
             (events (cdr (zmq-assoc sock socks-events))))
        (when (and events (member zmq-POLLIN events))
          (throw 'recvd (zmq-recv sock)))))))
#+END_SRC

Below is a table mapping the C API functions to their Emacs equivalent.

| C                      | emacs-lisp            |
|------------------------+-----------------------|
| =zmq_poller_new=       | =zmq-poller=          |
| =zmq_poller_destroy=   | =zmq-poller-destroy=  |
| =zmq_poller_add=       | =zmq-poller-add=      |
| =zmq_poller_add_fd=    | =zmq-poller-add=      |
| =zmq_poller_modify=    | =zmq-poller-modify=   |
| =zmq_poller_modify_fd= | =zmq-poller-modify=   |
| =zmq_poller_remove=    | =zmq-poller-remove=   |
| =zmq_poller_remove_fd= | =zmq-poller-remove=   |
| =zmq_poller_wait=      | =zmq-poller-wait=     |
| =zmq_poller_wait_all=  | =zmq-poller-wait-all= |
* Errors

All errors generated by the underlying =C= API are converted into calls to
=signal= in Emacs. So to handle errors, wrap your calls to =zmq= functions in a
=condition-case= like so

#+BEGIN_SRC elisp
(setq poll-events
      (while (null (condition-case nil
                       (zmq-poller-wait poller 1)
                     ((zmq-EAGAIN zmq-ETIMEDOUT) nil)))
        (sleep-for 1)))
#+END_SRC

The error symbols used are identical to the C error codes except with the
prefix =zmq-=.
* Comparing ZMQ objects

There are also predicate and comparison functions available for working with
ZMQ objects:

| zmq-poller-p  |
| zmq-socket-p  |
| zmq-context-p |
| zmq-message-p |
| zmq-equal     |
| zmq-assoc     |

=zmq-equal= and =zmq-assoc= work just like =equal= and =assoc= respectively,
but can also compare ZMQ objects.
* Getting/setting options

To set an option for a =zmq-context=, =zmq-socket=, or =zmq-message= call:

#+BEGIN_SRC elisp
(zmq-context-set ctx zmq-BLOCKY nil)
(zmq-socket-set sock zmq-IPV6 t)
(zmq-message-set msg zmq-MORE t)
#+END_SRC

To get an option:

#+BEGIN_SRC elisp
(zmq-context-get ctx zmq-BLOCKY)
(zmq-socket-get sock zmq-IPV6)
(zmq-message-get msg zmq-MORE)
#+END_SRC

Or the convenience functions =zmq-set-option= and =zmq-get-option= can be used
which will call one of the functions above based on the type of the first
argument:

#+BEGIN_SRC elisp
(zmq-set-option ctx zmq-BLOCKY nil)
(zmq-set-option sock zmq-IPV6 t)

(zmq-get-option ctx zmq-BLOCKY)
(zmq-get-option sock zmq-IPV6)
#+END_SRC

To access a =zmq-message= meta-data property use =zmq-message-property=:

#+BEGIN_SRC elisp
(zmq-message-property msg :identity)
#+END_SRC

The available metadata properties can be found in =zmq-message-properties=.

** Boolean options

Integer options which are interpreted as boolean in =libzmq= are interpreted in
Emacs as boolean. For example, the socket option =zmq-IPV6= which enables IPV6
connections for the socket is an integer option interpreted as a boolean value
in the C API. In Emacs this option is a boolean. So to enable IPV6 connections
you would do

#+BEGIN_SRC elisp
(zmq-socket-set sock zmq-IPV6 t)
#+END_SRC

and to disable them

#+BEGIN_SRC elisp
(zmq-socket-set sock zmq-IPV6 nil)
#+END_SRC

Similarly for all other socket, message, or context options which are
interpreted as boolean by the C API.
* Context/socket/poller lifetime management

The underlying Emacs module takes care of freeing the resources used by a ZMQ
object during garbage collection. As a special case if a socket gets garbage
collected, the =zmq=LINGER= property will be set to 0 for the socket
(http://zguide.zeromq.org/page:all#Making-a-Clean-Exit). You probably still
want to call the appropriate destructor function once your done using an object
though.
* Asynchronous subprocess

There is also the function =zmq-start-process= which creates an Emacs
subprocess that can then be used for all your =zmq= processing needs. You pass
=zmq-start-process= a function to run in the subprocess:

#+BEGIN_SRC elisp
(zmq-start-process
 (lambda ()
   (let* ((ctx (zmq-current-context))
          (sock (zmq-socket ctx zmq-SUB)))
     BODY)))
#+END_SRC

Or if you supply a function with a single argument to =zmq-start-process=, a
context will be created for you and passed as the argument to the function:

#+BEGIN_SRC elisp
(zmq-start-process
 (lambda (ctx)
   (let ((sock (zmq-socket ctx zmq-SUB)))
     BODY)))
#+END_SRC

For one-way communication between the parent Emacs process and the subprocess
created with =zmq-start-process= you can use =zmq-subprocess-send= in the
parent and =zmq-subprocess-read= in the child process. =zmq-subprocess-send=
takes a process object as its first argument and an arbitrary s-expression as
its second argument. The s-expression will be encoded and sent to the
subprocess. Using =zmq-subprocess-read= in the subprocess takes care of
decoding and returns the s-expression sent from the parent process.

#+BEGIN_SRC elisp
(let ((proc (zmq-start-process
             (lambda (ctx)
               (let ((poller (zmq-poller)))
                 ;; Poll for input on STDIN, i.e. input from the parent emacs
                 ;; process
                 (zmq-poller-register poller 0 zmq-POLLIN)
                 (catch 'exit
                   (while t
                     (when (zmq-poller-wait poller 100)
                       (let ((sexp (zmq-subprocess-read)))
                         (zmq-prin1 sexp)
                         (throw 'exit t)))))))
             ;; A filter function which prints out messages sent by the
             ;; subprocess.
             (lambda (sexp)
               (message "echo %s" sexp)))))
  ;; Let the process start
  (sleep-for 0.2)
  (zmq-subprocess-send proc (list 'send "topic1")))
#+END_SRC
